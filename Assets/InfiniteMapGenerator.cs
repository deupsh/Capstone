using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Tilemaps;

// 각 숫자가 지형을 의미
public enum Biome : int {
    Snow = 0, Cave = 1, Ocean = 2, Desert = 3, Forest = 4, Swamp = 5, Lava = 6, Grassland = 7, MAX          
}

public class ChunkLoader : MonoBehaviour {
    
    [Header("타일맵 관련")]
    [SerializeField] private Tilemap tileMap; // 타일맵 참조

    [Space]
    
    [Header("눈 지형")]
    [SerializeField] private TileBase snow, snow2; // 눈 타일
    [Header("동굴 지형")]
    [SerializeField] private TileBase cave, cave2; // 동굴 타일
    [Header("바다 지형")]
    [SerializeField] private TileBase ocean, ocean2; // 바다 타일
    [Header("사막 지형")]
    [SerializeField] private TileBase desert, desert2; // 사막 타일
    [Header("숲 지형")]
    [SerializeField] private TileBase forest, forest2; // 숲 타일
    [Header("습지 지형")]
    [SerializeField] private TileBase swamp, swamp2; // 습지 타일
    [Header("용암 지형")]
    [SerializeField] private TileBase lava, lava2; // 용암 타일
    [Header("초원 지형")]
    [SerializeField] private TileBase grassland, grassland2; // 초원 지역 타일들

    [Space]
    [Header("값 관련")]
    [SerializeField] private float mapScale = 0.01f; // 노이즈 : 자연스럽게 랜덤한 맵 생성
    [SerializeField] private int chunkSize = 16; // 청크 크기
    [SerializeField] private int worldSizeInChunks = 10; // 최초 생성 월드 크기

    [SerializeField] private int octaves = 3; // 옥타브 : 지형의 세부적 복잡도
    [SerializeField] private int pointNum = 2; // 바이옴 크기랑 반비례 (클수록 바이옴 크기가 작아짐)
    private float seed; // 시드 값

   // 청크 캐싱을 위한 딕셔너리 (로드된 청크 관리)
   private Dictionary<Vector3Int, bool> loadedChunks = new Dictionary<Vector3Int, bool>();
   // 타일 캐싱을 위한 딕셔너리 (타일 재생성 방지)
   private Dictionary<Vector3Int, TileBase> tileCache = new Dictionary<Vector3Int, TileBase>();

   void Start()
   {
       seed = Random.Range(0f, 10000f); // 시드 값 초기화
       GenerateFullMap(); // 전체 맵을 한 번에 생성
       StartCoroutine(UpdateChunks()); // 플레이어 이동에 따라 청크 업데이트
   }

   // 최초 생성맵을 생성하는 함수
   private void GenerateFullMap()
   {
       for (int chunkX = 0; chunkX < worldSizeInChunks; chunkX++)
       {
           for (int chunkY = 0; chunkY < worldSizeInChunks; chunkY++)
           {
               Vector3Int chunkPos = new Vector3Int(chunkX, chunkY, 0);
               LoadChunk(chunkPos);
           }
       }
   }

   // 플레이어의 현재 청크 좌표를 가져오는 함수
   private Vector3Int GetPlayerChunkPosition()
   {
       Vector3 playerPosition = Camera.main.transform.position;

       return new Vector3Int(
           Mathf.FloorToInt(playerPosition.x / chunkSize),
           Mathf.FloorToInt(playerPosition.y / chunkSize),
           0
       );
   }

   // 플레이어 이동에 따라 청크를 업데이트하는 함수
   private IEnumerator UpdateChunks()
   {
       while (true)
       {
           Vector3Int currentPlayerChunk = GetPlayerChunkPosition();
           LoadSurroundingChunks(currentPlayerChunk); // 새로운 주변 청크 로드
           UnloadDistantChunks(currentPlayerChunk); // 멀어진 청크 언로드

           yield return new WaitForSeconds(0.5f); // 0.5초마다 체크
       }
   }

   // 주변 청크들을 로드하는 함수
   private void LoadSurroundingChunks(Vector3Int centerChunk)
   {
       for (int xOffset = -1; xOffset <= 1; xOffset++)
       {
           for (int yOffset = -1; yOffset <= 1; yOffset++)
           {
               Vector3Int chunkPos = new Vector3Int(centerChunk.x + xOffset, centerChunk.y + yOffset, 0);

               if (!loadedChunks.ContainsKey(chunkPos)) 
               {
                   LoadChunk(chunkPos); // 주변 청크가 로드되지 않았으면 로드
                   loadedChunks[chunkPos] = true;
               }
           }
       }
   }

   // 멀어진 청크들을 언로드하는 함수
   private void UnloadDistantChunks(Vector3Int centerChunk)
   {
       List<Vector3Int> chunksToUnload = new List<Vector3Int>();

       foreach (var chunk in loadedChunks.Keys)
       {
           if (Vector3Int.Distance(chunk, centerChunk) > 2) // 일정 거리 이상 떨어진 청크는 언로드
           {
               chunksToUnload.Add(chunk);
           }
       }

       foreach (var chunk in chunksToUnload)
       {
           UnloadChunk(chunk);
           loadedChunks.Remove(chunk);
       }
   }

   // 특정 청크를 로드하는 함수 (타일 캐싱 적용)
   private void LoadChunk(Vector3Int chunkPos) {
       if (!loadedChunks.ContainsKey(chunkPos)) {         // 이미 로드된 청크가 아니면 처리 시작

           float[,] noiseArr = GenerateNoise(chunkPos);   // 노이즈 배열 생성 (지형 높이 정보)
           Vector2[] randomPoints = GenerateRandomPos(pointNum);   // 랜덤 포인트 생성 (바이옴 결정용)
           Vector2[] biomePoints = GenerateRandomPos((int)Biome.MAX);   // 바이옴 포인트 생성

           Biome[,] biomeArr = GenerateBiome(randomPoints, biomePoints);   // 바이옴 배열 생성

           for (int x=0;x<chunkSize;x++) {               // 각 타일 위치에 대해 처리 시작 
               for (int y=0;y<chunkSize;y++) {
                   Vector3Int tilePos=new Vector3Int(chunkPos.x*chunkSize+x,chunkPos.y*chunkSize+y,0);
                   
                   if(!tileCache.ContainsKey(tilePos)) {   // 해당 위치에 타일이 없으면 새로 설정
                       TileBase tile=GetTileByHight(noiseArr[x,y],biomeArr[x,y]);   // 높이와 바이옴에 따라 적절한 타일 선택
                       tileMap.SetTile(tilePos,tile);      // 타일맵에 타일 설정
                       tileCache[tilePos]=tile;            // 캐시에 저장하여 재생성 방지
                   }
               }
           }
       }
   }

   // 특정 청크를 언로드하는 함수 (타일맵에서 제거)
   private void UnloadChunk(Vector3Int chunkPos)
   {
       for (int x=0;x<chunkSize;x++)
       {
           for (int y=0;y<chunkSize;y++)
           {
               Vector3Int tilePos=new Vector3Int(chunkPos.x*chunkSize+x,chunkPos.y*chunkSize+y,0);

               if(tileCache.ContainsKey(tilePos))
               {
                   tileMap.SetTile(tilePos,null); // 타일맵에서 제거
                   tileCache.Remove(tilePos); 
               }
           }
       }
   }

   // 노이즈 배열을 생성하는 함수 (청크별로)
   private float[,] GenerateNoise(Vector3Int chunkPos)
   {
       float[,] noiseArr=new float[chunkSize,chunkSize];
       float min=float.MaxValue,max=float.MinValue;

       for(int x=0;x<chunkSize;x++)
       {
           for(int y=0;y<chunkSize;y++)
           {
               float lacunarity=2.0f;
               float gain=0.5f;

               float amplitude=0.5f;
               float frequency=1f;

               int worldX=chunkPos.x*chunkSize+x;
               int worldY=chunkPos.y*chunkSize+y;

               for(int i=0;i<octaves;i++)
               {
                   noiseArr[x,y]+=amplitude*(Mathf.PerlinNoise(
                       seed+(worldX*mapScale*frequency),
                       seed+(worldY*mapScale*frequency))*2-1);

                   frequency*=lacunarity;
                   amplitude*=gain;
               }

               if(noiseArr[x,y]<min)min=noiseArr[x,y];
               if(noiseArr[x,y]>max)max=noiseArr[x,y];
           }
       }

       for(int x=0;x<chunkSize;x++)
       {
           for(int y=0;y<chunkSize;y++)
           {
               noiseArr[x,y]=Mathf.InverseLerp(min,max,noiseArr[x,y]);
           }
       }

       return noiseArr;
   }

   // 바이옴 배열을 생성하는 함수
   private Biome[,] GenerateBiome(Vector2[] points, Vector2[] biomePoints)
   {
       Biome[,] biomeArr=new Biome[chunkSize,chunkSize];

       for(int x=0;x<chunkSize;x++)
       {
           for(int y=0;y<chunkSize;y++)
           {
               float minDist=float.MaxValue;
               int idx=-1;

               for(int i=0;i<pointNum;i++)
               {
                   float dist=Vector2.Distance(points[i],new Vector2(x,y));

                   if(dist<minDist)
                   {
                       minDist=dist;
                       idx=i;
                   }
               }

               biomeArr[x,y]=(Biome)GetMinIdx(points[idx],biomePoints);
           }
       }

       return biomeArr;
   }

   // 랜덤 위치 배열을 생성하는 함수
   private Vector2[] GenerateRandomPos(int num)
   {
       Vector2[] arr=new Vector2[num];

       for(int i=0;i<num;i++)
       {
           int x=Random.Range(0,chunkSize-1);
           int y=Random.Range(0,chunkSize-1);

           arr[i]=new Vector2(x,y);
       }

       return arr;
   }

   // 가장 가까운 바이옴 인덱스를 계산하는 함수
   private int GetMinIdx(Vector2 point,Vector2[] biomeArr)
   {
       int curIdx=0;
       float min=float.MaxValue;

       for(int i=0;i<biomeArr.Length;i++)
       {
           float value=Vector2.Distance(point,biomeArr[i]);

           if(min>value)
           {
               min=value;
               curIdx=i;
           }
       }

       return curIdx;
   }

   // 타일맵에 타일을 설정하는 함수
   private void SettingTileMap(float[,] noiseArr,Biome[,] biomeArr)
   {
       Vector3Int point=Vector3Int.zero;

       for(int x=0;x<chunkSize;x++)
       {
           for(int y=0;y<chunkSize;y++)
           {
               point.Set(x,y,0);
               tileMap.SetTile(point,GetTileByHight(noiseArr[x,y],biomeArr[x,y]));
           }
       }
   }

   // 높이에 따른 타일을 결정하는 함수
   private TileBase GetTileByHight(float hight,Biome biome)
   {
       if(biome==Biome.Snow)
       {
           switch(hight)
           {
               case<=0.35f:return snow;
               case<=0.45f:return snow2;
               case<=0.6f:return snow;
               default:return snow;
           }
       }
       else if(biome==Biome.Cave)
       {
           switch(hight)
           {
               case<=0.35f:return cave;
               case<=0.45f:return cave2;
               case<=0.6f:return cave;
               default:return cave2;

           }
       }
       else if(biome==Biome.Ocean)
       {
           switch(hight)
           {
               case<=0.35f:return ocean;
               case<=0.45f:return ocean2;
               case<=0.6f:return ocean;
               default:return ocean2;
           }
       }
       else if(biome==Biome.Desert)
       {
           switch(hight)
           {
               case<=0.35f:return desert;
               case<=0.45f:return desert2;
               case<=0.6f:return desert;
               default:return desert2;
           }
       }
       else if(biome==Biome.Forest)
       {
           switch(hight)
           {
               case<=0.35f:return forest;
               case<=0.45f:return forest2;
               case<=0.6f:return forest;
               default:return forest2;
           }
       }
       else if(biome==Biome.Swamp)
       {
           switch(hight)
           {
               case<=0.35f:return swamp;
               case<=0.45f:return swamp2;
               case<=0.6f:return swamp;
               default:return swamp2;
           }
       }
       else if(biome==Biome.Lava)
       {
           switch(hight)
           {
               case<=0.35f:return lava;
               case<=0.45f:return lava2;
               case<=0.6f:return lava;
               default:return lava2;
           }
       }
       else if(biome==Biome.Grassland)
       {
           switch(hight)
           {
               case<=0.35f:return grassland;
               case<=0.45f:return grassland2;
               case<=0.6f:return grassland;
               default:return grassland2;
           }
       }
       
      return grassland; 
   } 
}